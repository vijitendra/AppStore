import { useState, useEffect, useRef } from "react";
import { useLocation } from "wouter";
import { Helmet } from "react-helmet";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { z } from "zod";
import { ArrowLeft, Upload, ImagePlus, PlusCircle, X, FileCode, FileArchive, Search, Download } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Progress } from "@/components/ui/progress";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Card, CardContent } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { queryClient } from "@/lib/queryClient";
import DeveloperLayout from "@/components/developer/developer-layout";
import { appCategories, appUploadSchema } from "@shared/schema";
import { extractApkMetadata, sdkToAndroidVersion, type ApkMetadata } from "@/lib/apk-extractor";
import { fetchPlayStoreInfo, downloadImageAsFile, type PlayStoreAppInfo } from "@/lib/play-store-api";

type AppUploadFormValues = z.infer<typeof appUploadSchema> & {
  apkFile: FileList;
  icon: FileList;
  screenshots: FileList;
};

export default function AppUploadPage() {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const [iconPreview, setIconPreview] = useState<string | null>(null);
  const [screenshotPreviews, setScreenshotPreviews] = useState<string[]>([]);
  const [apkProgress, setApkProgress] = useState<number>(0);
  const [isParsingApk, setIsParsingApk] = useState<boolean>(false);
  const [apkMetadata, setApkMetadata] = useState<ApkMetadata | null>(null);
  const [isImportDialogOpen, setIsImportDialogOpen] = useState<boolean>(false);
  const [packageNameToImport, setPackageNameToImport] = useState<string>("");
  const [isImporting, setIsImporting] = useState<boolean>(false);
  const [importError, setImportError] = useState<string | null>(null);

  // Create a base schema first without the refine method
  const baseSchema = z.object({
    name: z.string().min(1, "App name is required"),
    description: z.string().min(10, "Description must be at least 10 characters"),
    shortDescription: z.string().optional(),
    version: z.string().optional(),
    versionCode: z.number().optional(),
    packageName: z.string().optional(),
    category: z.string().min(1, "Category is required"),
    minAndroidVersion: z.string().default("5.0"),
    changeLog: z.string().optional(),
  });

  const form = useForm<AppUploadFormValues>({
    resolver: zodResolver(
      z.object({
        ...baseSchema.shape,
        apkFile: z.instanceof(FileList).refine(files => files.length === 1, {
          message: "APK file is required",
        }),
        icon: z.instanceof(FileList).refine(files => files.length === 1, {
          message: "App icon is required",
        }),
        screenshots: z.instanceof(FileList).refine(files => files.length >= 1 && files.length <= 5, {
          message: "At least 1 and at most 5 screenshots are required",
        }),
      })
    ),
    defaultValues: {
      name: "",
      description: "",
      shortDescription: "",
      version: "1.0.0",
      versionCode: 1,
      packageName: "",
      category: "",
      minAndroidVersion: "5.0",
    },
  });

  const uploadMutation = useMutation({
    mutationFn: async (data: AppUploadFormValues) => {
      const formData = new FormData();

      // Add all form fields to formData
      Object.entries(data).forEach(([key, value]) => {
        if (key !== 'apkFile' && key !== 'icon' && key !== 'screenshots') {
          // For number fields, ensure they're sent as strings
          if (key === 'versionCode') {
            formData.append(key, String(value));
          } else {
            formData.append(key, value as string);
          }
          console.log(`Appending form field: ${key} = ${value}`); // Debug log
        }
      });

      // Add files
      formData.append('apkFile', data.apkFile[0]);
      formData.append('icon', data.icon[0]);

      // Add screenshots
      for (let i = 0; i < data.screenshots.length; i++) {
        formData.append('screenshots', data.screenshots[i]);
      }

      const response = await fetch('/api/developer/apps', {
        method: 'POST',
        body: formData,
        credentials: 'include',
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('App upload error details:', errorData);

        // Create a more detailed error message
        let errorMessage = errorData.message || 'Failed to upload app';

        // If we have validation errors, add them to the message
        if (errorData.errors && errorData.errors.length > 0) {
          const fieldErrors = errorData.errors.map((err: any) => {
            return `${err.path.join('.')}: ${err.message}`;
          }).join(', ');

          errorMessage += `: ${fieldErrors}`;
        }

        // If we have debug info, log it
        if (errorData.debugInfo) {
          console.log('Debug info:', errorData.debugInfo);
        }

        throw new Error(errorMessage);
      }

      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: "App uploaded successfully",
        description: "Your app has been uploaded and is now available.",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/developer/apps"] });
      navigate("/developer");
    },
    onError: (error: Error) => {
      toast({
        title: "Upload failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Effect to set form values from APK metadata
  useEffect(() => {
    // Apply a default app name and description even if APK extraction fails
    // This ensures the form has valid data to submit
    const ensureRequiredFields = (formData: Partial<AppUploadFormValues>) => {
      const values = { ...formData };

      // Ensure we have at least the required fields for form validation
      if (!values.name || values.name.trim() === '') {
        const filename = form.getValues('apkFile')?.[0]?.name;
        if (filename) {
          // Extract app name from filename (remove extension and transform)
          const nameFromFile = filename.replace(/\.(apk|aab)$/i, '')
            .replace(/[-_]/g, ' ')
            .replace(/([a-z])([A-Z])/g, '$1 $2'); // Add space between camelCase words

          values.name = nameFromFile;
          console.log('Using filename as app name:', values.name);
        } else {
          values.name = 'My App'; // Fallback
        }
      }

      // Ensure we have a description
      if (!values.description || values.description.trim() === '' || 
          values.description.length < 10) {
        values.description = `Welcome to ${values.name}. This mobile application provides users with an engaging experience.`;
        console.log('Setting default description');
      }

      // Ensure short description
      if (!values.shortDescription || values.shortDescription.trim() === '') {
        values.shortDescription = `Welcome to ${values.name}`;
      }

      // Ensure change log
      if (!values.changeLog || values.changeLog.trim() === '') {
        values.changeLog = `Initial release of ${values.name}`;
      }

      // Ensure category
      if (!values.category || values.category.trim() === '') {
        values.category = 'Games';
      }

      // Ensure version info is filled
      if (!values.version || values.version.trim() === '') {
        values.version = '1.0.0';
      }

      if (!values.versionCode || values.versionCode <= 0) {
        values.versionCode = 1;
      }

      // Ensure Android version is set
      if (!values.minAndroidVersion || values.minAndroidVersion.trim() === '') {
        values.minAndroidVersion = '5.0';
      }

      return values;
    };

    if (apkMetadata) {
      console.log('Setting form values from APK metadata:', apkMetadata);

      try {
        // Directly set the values first to avoid delay
        if (apkMetadata.versionName) {
          console.log('ðŸ‘‰ Directly setting version name:', apkMetadata.versionName);
          form.setValue('version', apkMetadata.versionName);
        }

        if (apkMetadata.versionCode) {
          console.log('ðŸ‘‰ Directly setting version code:', apkMetadata.versionCode);
          form.setValue('versionCode', apkMetadata.versionCode);
        }

        if (apkMetadata.packageName) {
          console.log('ðŸ‘‰ Directly setting package name:', apkMetadata.packageName);
          form.setValue('packageName', apkMetadata.packageName);
        }

        // Prepare a batch of updates to apply all at once
        let updates: Partial<AppUploadFormValues> = {};

        // Transfer metadata values to form updates
        if (apkMetadata.appName) {
          console.log('Setting app name:', apkMetadata.appName);
          updates.name = apkMetadata.appName;
        }

        if (apkMetadata.versionName) {
          console.log('Setting version name:', apkMetadata.versionName);
          updates.version = apkMetadata.versionName;
        }

        if (apkMetadata.versionCode) {
          console.log('Setting version code:', apkMetadata.versionCode);
          updates.versionCode = apkMetadata.versionCode;
        }

        if (apkMetadata.packageName) {
          console.log('Setting package name:', apkMetadata.packageName);
          updates.packageName = apkMetadata.packageName;
        }

        if (apkMetadata.minSdkVersion) {
          const androidVersion = sdkToAndroidVersion(apkMetadata.minSdkVersion);
          if (androidVersion) {
            console.log('Setting Android version:', androidVersion);
            updates.minAndroidVersion = androidVersion;
          }
        }

        // Even if we have no metadata, derive some sensible defaults
        // from the filename for APK/AAB
        if (Object.keys(updates).length === 0) {
          const filename = form.getValues('apkFile')?.[0]?.name;
          if (filename) {
            // Try to extract version from filename like "app-v1.2.3.apk"
            const versionMatch = filename.match(/[-_]v?(\d+\.\d+(\.\d+)?)/i);
            if (versionMatch && versionMatch[1]) {
              console.log('Extracted version from filename:', versionMatch[1]);
              updates.version = versionMatch[1];

              // Derive a version code from this version
              const parts = versionMatch[1].split('.');
              if (parts.length >= 2) {
                let code = 0;
                if (parts.length >= 3) {
                  // 1.2.3 -> 10203
                  code = parseInt(parts[0]) * 10000 + parseInt(parts[1]) * 100 + parseInt(parts[2]);
                } else {
                  // 1.2 -> 10200
                  code = parseInt(parts[0]) * 10000 + parseInt(parts[1]) * 100;
                }

                if (!isNaN(code) && code > 0) {
                  updates.versionCode = code;
                  console.log('Derived version code from filename:', code);
                }
              }
            } else if (filename.match(/[-_](\d+)/)) {
              // Try to extract a version from patterns like "app-123.apk" or "app_19.apk"
              const numericMatch = filename.match(/[-_](\d+)/);
              if (numericMatch && numericMatch[1]) {
                const versionNum = parseInt(numericMatch[1], 10);
                if (!isNaN(versionNum)) {
                  // Convert '19' to '1.9.0'
                  if (versionNum < 100) {
                    updates.version = `${Math.floor(versionNum / 10)}.${versionNum % 10}.0`;
                    console.log('Converted numeric version from filename:', updates.version);
                  } else {
                    // Just use as version code
                    updates.versionCode = versionNum;
                    console.log('Using numeric part of filename as version code:', versionNum);
                  }
                }
              }
            }
          }
        }

        // Ensure all required fields have values and descriptions are added
        // based on the app name if available
        updates = ensureRequiredFields(updates);

        // Apply all updates at once using batch update to avoid validation issues
        form.reset({
          ...form.getValues(),
          ...updates
        }, { 
          keepValues: true, 
          keepErrors: false, 
          keepDirty: false 
        });

        // Force direct updates for certain fields like selects that need special handling
        if (updates.category) {
          console.log('Forcing category update to:', updates.category);
          form.setValue('category', updates.category);
        }

        if (updates.minAndroidVersion) {
          console.log('Forcing Android version update to:', updates.minAndroidVersion);
          form.setValue('minAndroidVersion', updates.minAndroidVersion);
        }

        if (updates.version) {
          console.log('Forcing version update to:', updates.version);
          form.setValue('version', updates.version);
        }

        if (updates.versionCode) {
          console.log('Forcing version code update to:', updates.versionCode);
          form.setValue('versionCode', updates.versionCode);
        }

        // Trigger validation after all values are set
        void form.trigger();

        // Debug: log form values and any remaining errors
        setTimeout(() => {
          console.log('Form values after setting:', form.getValues());
          console.log('Form errors:', form.formState.errors);

          // If we still have errors, try to fix them one by one
          const errors = form.formState.errors;
          if (errors.name) {
            console.log('Still have name error, setting default name');
            form.setValue('name', 'My App');
          }
          if (errors.description) {
            console.log('Still have description error, setting default description');
            form.setValue('description', 'This mobile application provides users with an engaging experience and numerous features for your enjoyment.');
          }
          if (errors.category) {
            console.log('Still have category error, setting default category');
            form.setValue('category', 'Games');
          }

          // Final validation trigger to clear errors
          void form.trigger();
        }, 300);
      } catch (e) {
        console.error('Error applying form updates:', e);
      }
    }
  }, [apkMetadata, form]);

  // Handle importing app from Play Store
  async function importFromPlayStore(packageName: string) {
    if (!packageName.trim()) {
      setImportError('Package name is required');
      return;
    }

    setIsImporting(true);
    setImportError(null);

    try {
      // Fetch app info from Play Store
      const appInfo = await fetchPlayStoreInfo(packageName);
      console.log('Fetched app info from Play Store:', appInfo);

      // Set form values from app info
      form.setValue('name', appInfo.name || '');
      form.setValue('description', appInfo.description || '');
      form.setValue('shortDescription', appInfo.shortDescription || '');
      form.setValue('packageName', packageName);

      // Try to match category to one in our list
      const categoryMatch = appCategories.find(cat => 
        appInfo.category.toLowerCase().includes(cat.toLowerCase())
      );
      if (categoryMatch) {
        form.setValue('category', categoryMatch);
      } else {
        // Default to Games if no match
        form.setValue('category', 'Games');
      }

      // Download icon
      if (appInfo.icon) {
        try {
          const iconFile = await downloadImageAsFile(appInfo.icon, 'icon.png', 'image/png');
          const iconFileList = new DataTransfer();
          iconFileList.items.add(iconFile);
          form.setValue('icon', iconFileList.files);

          // Preview the icon
          setIconPreview(URL.createObjectURL(iconFile));
        } catch (err) {
          console.error('Error downloading icon:', err);
          toast({
            title: "Warning",
            description: "Couldn't download app icon. Please upload it manually.",
          });
        }
      }

      // Download screenshots
      if (appInfo.screenshots && appInfo.screenshots.length > 0) {
        try {
          const screenshotFiles = new DataTransfer();
          const previewUrls: string[] = [];

          // Only take up to 5 screenshots
          const maxScreenshots = Math.min(5, appInfo.screenshots.length);

          for (let i = 0; i < maxScreenshots; i++) {
            const screenshot = appInfo.screenshots[i];
            const file = await downloadImageAsFile(screenshot, `screenshot_${i}.png`, 'image/png');
            screenshotFiles.items.add(file);

            // Preview the screenshot
            previewUrls.push(URL.createObjectURL(file));
          }

          form.setValue('screenshots', screenshotFiles.files);
          setScreenshotPreviews(previewUrls);
        } catch (err) {
          console.error('Error downloading screenshots:', err);
          toast({
            title: "Warning",
            description: "Couldn't download app screenshots. Please upload them manually.",
          });
        }
      }

      // Close the dialog
      setIsImportDialogOpen(false);

      toast({
        title: "Import Successful",
        description: "App info has been imported from Google Play Store.",
      });
    } catch (error) {
      console.error('Error importing from Play Store:', error);
      setImportError('Failed to import app info. Make sure the package name is correct.');
    } finally {
      setIsImporting(false);
    }
  }

  function onSubmit(data: AppUploadFormValues) {
    console.log('Form submitted with values:', data);
    uploadMutation.mutate(data);
  }

  // Handle apk file change
  const handleApkFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];
    form.setValue('apkFile', files);

    try {
      setIsParsingApk(true);
      setApkProgress(10);

      // Create a blob URL for the file
      const blobUrl = URL.createObjectURL(file);

      // Fetch the file content
      const response = await fetch(blobUrl);
      const blob = await response.blob();
      setApkProgress(30);

      // Create a FormData object to send the file to the server
      const formData = new FormData();
      formData.append('apkFile', blob, file.name);
      setApkProgress(50);

      // Send the file to the server for extraction
      const extractResponse = await fetch('/api/developer/extract-apk', {
        method: 'POST',
        body: formData,
      });

      if (!extractResponse.ok) {
        const errorData = await extractResponse.json();
        console.error('APK extraction error:', errorData);
        throw new Error(errorData.message || 'Failed to extract APK metadata');
      }

      setApkProgress(80);
      const metadata = await extractResponse.json();
      console.log('Successfully extracted APK metadata:', metadata);

      setApkProgress(100);
      setApkMetadata(metadata);

      toast({
        title: "APK Parsed",
        description: "Metadata extracted successfully.",
      });
    } catch (error) {
      console.error('Error processing APK file:', error);
      toast({
        title: "APK Parsing Failed",
        description: error instanceof Error ? error.message : "Failed to extract metadata from APK.",
        variant: "destructive",
      });

      // Even if extraction fails, we still set the file
      form.setValue('apkFile', files);

      // Try to extract some information from the filename
      const filename = file.name;
      if (filename) {
        const nameWithoutExt = filename.replace(/\.(apk|aab)$/i, '')
          .replace(/[-_]/g, ' ')
          .replace(/([a-z])([A-Z])/g, '$1 $2');

        console.log('Using filename as app name:', nameWithoutExt);
        form.setValue('name', nameWithoutExt);

        // Try to extract version from filename
        const versionMatch = filename.match(/[-_]v?(\d+\.\d+(\.\d+)?)/i);
        if (versionMatch && versionMatch[1]) {
          form.setValue('version', versionMatch[1]);
        }
      }
    } finally {
      setIsParsingApk(false);
    }
  };

  // Handle icon file change
  const handleIconChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];
    form.setValue('icon', files);

    const iconURL = URL.createObjectURL(file);
    setIconPreview(iconURL);
  };

  // Handle screenshots file change
  const handleScreenshotsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files) return;

    const screenshotURLs: string[] = [];

    // Only take up to 5 screenshots
    const maxScreenshots = Math.min(5, files.length);

    for (let i = 0; i < maxScreenshots; i++) {
      const file = files[i];
      const screenshotURL = URL.createObjectURL(file);
      screenshotURLs.push(screenshotURL);
    }

    form.setValue('screenshots', files);
    setScreenshotPreviews(screenshotURLs);
  };

  // Clear screenshots
  const clearScreenshots = () => {
    form.setValue('screenshots', undefined);
    setScreenshotPreviews([]);
  };

  return (
      <Helmet>
        <title>Upload App - Developer Dashboard - AppMarket</title>
        <meta name="description" content="Upload your Android APK or AAB file to AppMarket and start reaching users." />
      </Helmet>

      <div className="max-w-3xl mx-auto">
        <div className="mb-6">
          <Button variant="ghost" size="sm" onClick={() => navigate("/developer")} className="mb-2">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Dashboard
          </Button>
          <h1 className="text-2xl font-bold">Upload New App</h1>
          <p className="text-gray-500">Fill out the details below to upload your app</p>
        </div>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            <div className="bg-white rounded-lg shadow-sm p-6 border">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">App Information</h2>
                <Dialog open={isImportDialogOpen} onOpenChange={setIsImportDialogOpen}>
                  <DialogTrigger asChild>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      className="gap-2"
                    >
                      <Search className="h-4 w-4" />
                      Import from Play Store
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>Import from Google Play Store</DialogTitle>
                      <DialogDescription>
                        Enter an Android package name to import app information automatically.
                      </DialogDescription>
                    </DialogHeader>
                    <div className="py-4">
                      <div className="space-y-4">
                        <div className="space-y-2">
                          <Input
                            placeholder="com.example.app"
                            value={packageNameToImport}
                            onChange={(e) => setPackageNameToImport(e.target.value)}
                          />
                          <p className="text-xs text-gray-500">
                            Example format: com.whatsapp
                          </p>
                        </div>

                        {importError && (
                          <Alert variant="destructive" className="py-2 text-sm">
                            <AlertDescription>{importError}</AlertDescription>
                          </Alert>
                        )}
                      </div>
                    </div>
                    <DialogFooter>
                      <Button
                        type="button"
                        variant="outline"
                        onClick={() => setIsImportDialogOpen(false)}
                      >
                        Cancel
                      </Button>
                      <Button
                        type="button"
                        onClick={() => importFromPlayStore(packageNameToImport)}
                        disabled={isImporting || !packageNameToImport.trim()}
                        className="gap-2"
                      >
                        {isImporting ? (
                          <>
                            <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Importing...
                          </>
                        ) : (
                          <>
                            <Download className="h-4 w-4" />
                            Import Data
                          </>
                        )}
                      </Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>

              <div className="space-y-4">
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>App Name</FormLabel>
                      <FormControl>
                        <Input placeholder="Enter app name" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="packageName"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Package Name</FormLabel>
                        <FormControl>
                          <Input placeholder="com.example.app" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="version"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Version</FormLabel>
                        <FormControl>
                          <Input placeholder="1.0.0" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="versionCode"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Version Code</FormLabel>
                      <FormControl>
                        <Input 
                          type="number" 
                          placeholder="1" 
                          {...field}
                          onChange={(e) => field.onChange(parseInt(e.target.value, 10) || 1)}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="category"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Category</FormLabel>
                        <Select 
                          onValueChange={field.onChange} 
                          value={field.value || undefined}
                        >
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Select a category" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {appCategories.map(category => (
                              <SelectItem key={category} value={category}>
                                {category}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="minAndroidVersion"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Min Android Version</FormLabel>
                        <Select 
                          onValueChange={field.onChange} 
                          value={field.value || undefined}
                        >
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Select Android version" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="5.0">5.0 (Lollipop)</SelectItem>
                            <SelectItem value="6.0">6.0 (Marshmallow)</SelectItem>
                            <SelectItem value="7.0">7.0 (Nougat)</SelectItem>
                            <SelectItem value="8.0">8.0 (Oreo)</SelectItem>
                            <SelectItem value="9.0">9.0 (Pie)</SelectItem>
                            <SelectItem value="10.0">10.0 (Q)</SelectItem>
                            <SelectItem value="11.0">11.0 (R)</SelectItem>
                            <SelectItem value="12.0">12.0 (S)</SelectItem>
                            <SelectItem value="13.0">13.0 (T)</SelectItem>
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="shortDescription"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Short Description</FormLabel>
                      <FormControl>
                        <Input 
                          placeholder="Brief description (shown in listings)" 
                          {...field} 
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Full Description</FormLabel>
                      <FormControl>
                        <Textarea 
                          placeholder="Detailed description of your app" 
                          rows={5}
                          {...field} 
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="changeLog"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Change Log</FormLabel>
                      <FormControl>
                        <Textarea 
                          placeholder="What's new in this version" 
                          rows={3}
                          {...field} 
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </div>

            <div className="bg-white rounded-lg shadow-sm p-6 border">
              <h2 className="text-lg font-semibold mb-4">APK File</h2>

              <FormField
                control={form.control}
                name="apkFile"
                render={({ field: { value, onChange, ...field } }) => (
                  <FormItem>
                    <FormLabel>APK File</FormLabel>
                    <FormControl>
                      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
                        <label className="flex flex-col items-center justify-center cursor-pointer">
                          <div className="flex flex-col items-center justify-center">
                            <FileArchive className="h-10 w-10 text-gray-400" />
                            <span className="mt-2 text-sm font-medium text-gray-700">
                              {value && value.length > 0
                                ? `Selected file: ${value[0].name}`
                                : "Click to select APK file"}
                            </span>
                            <span className="mt-1 text-xs text-gray-500">
                              Upload APK or AAB file (max 500MB)
                            </span>
                          </div>
                          <input
                            type="file"
                            className="hidden"
                            accept=".apk,.aab"
                            onChange={(e) => {
                              handleApkFileChange(e);
                            }}
                            {...field}
                          />
                        </label>
                      </div>
                    </FormControl>
                    <FormMessage />

                    {isParsingApk && (
                      <div className="mt-4">
                        <div className="flex items-center mb-2">
                          <span className="text-xs text-gray-500 mr-2">Extracting metadata...</span>
                          <span className="text-xs font-medium text-gray-700">{apkProgress}%</span>
                        </div>
                        <Progress value={apkProgress} />
                      </div>
                    )}

                    {apkMetadata && Object.keys(apkMetadata).length > 0 && (
                      <Card className="mt-4">
                        <CardContent className="p-4">
                          <div className="text-sm font-medium text-gray-700 mb-2">Extracted Metadata</div>
                          <div className="text-xs space-y-1">
                            {apkMetadata.packageName && (
                              <div>
                                <span className="font-semibold">Package Name:</span>{" "}
                                {apkMetadata.packageName}
                              </div>
                            )}
                            {apkMetadata.versionName && (
                              <div>
                                <span className="font-semibold">Version Name:</span>{" "}
                                {apkMetadata.versionName}
                              </div>
                            )}
                            {apkMetadata.versionCode && (
                              <div>
                                <span className="font-semibold">Version Code:</span>{" "}
                                {apkMetadata.versionCode}
                              </div>
                            )}
                            {apkMetadata.minSdkVersion && (
                              <div>
                                <span className="font-semibold">Min SDK:</span>{" "}
                                {apkMetadata.minSdkVersion} (Android{" "}
                                {sdkToAndroidVersion(apkMetadata.minSdkVersion)})
                              </div>
                            )}
                            {apkMetadata.targetSdkVersion && (
                              <div>
                                <span className="font-semibold">Target SDK:</span>{" "}
                                {apkMetadata.targetSdkVersion} (Android{" "}
                                {sdkToAndroidVersion(apkMetadata.targetSdkVersion)})
                              </div>
                            )}
                            {apkMetadata.appName && (
                              <div>
                                <span className="font-semibold">App Name:</span>{" "}
                                {apkMetadata.appName}
                              </div>
                            )}
                          </div>
                        </CardContent>
                      </Card>
                    )}
                  </FormItem>
                )}
              />
            </div>

            <div className="bg-white rounded-lg shadow-sm p-6 border">
              <h2 className="text-lg font-semibold mb-4">App Icon</h2>

              <FormField
                control={form.control}
                name="icon"
                render={({ field: { value, onChange, ...field } }) => (
                  <FormItem>
                    <FormLabel>Icon Image</FormLabel>
                    <FormControl>
                      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
                        <label className="flex flex-col items-center justify-center cursor-pointer">
                          <div className="flex flex-col items-center justify-center">
                            {iconPreview ? (
                              <img
                                src={iconPreview}
                                alt="App icon preview"
                                className="h-24 w-24 object-contain rounded-xl border border-gray-200"
                              />
                            ) : (
                              <ImagePlus className="h-10 w-10 text-gray-400" />
                            )}
                            <span className="mt-2 text-sm font-medium text-gray-700">
                              {value && value.length > 0
                                ? `Selected icon: ${value[0].name}`
                                : "Click to select app icon"}
                            </span>
                            <span className="mt-1 text-xs text-gray-500">
                              PNG or JPEG, 512x512px recommended
                            </span>
                          </div>
                          <input
                            type="file"
                            className="hidden"
                            accept="image/*"
                            onChange={handleIconChange}
                            {...field}
                          />
                        </label>
                      </div>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="bg-white rounded-lg shadow-sm p-6 border">
              <h2 className="text-lg font-semibold mb-4">App Screenshots</h2>

              <FormField
                control={form.control}
                name="screenshots"
                render={({ field: { value, onChange, ...field } }) => (
                  <FormItem>
                    <FormLabel>Screenshots (1-5)</FormLabel>
                    <FormControl>
                      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
                        <label className="flex flex-col items-center justify-center cursor-pointer">
                          <div className="flex flex-col items-center justify-center">
                            <Upload className="h-10 w-10 text-gray-400" />
                            <span className="mt-2 text-sm font-medium text-gray-700">
                              {value && value.length > 0
                                ? `Selected ${value.length} screenshots`
                                : "Click to select screenshots"}
                            </span>
                            <span className="mt-1 text-xs text-gray-500">
                              PNG or JPEG, select 1-5 images
                            </span>
                          </div>
                          <input
                            type="file"
                            className="hidden"
                            accept="image/*"
                            multiple
                            onChange={handleScreenshotsChange}
                            {...field}
                          />
                        </label>
                      </div>
                    </FormControl>

                    {screenshotPreviews.length > 0 && (
                      <div className="mt-4">
                        <div className="flex justify-between items-center mb-2">
                          <div className="text-sm font-medium text-gray-700">Screenshot Previews</div>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={clearScreenshots}
                          >
                            <X className="h-4 w-4 mr-1" />
                            Clear All
                          </Button>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                          {screenshotPreviews.map((url, index) => (
                            <div key={index} className="relative rounded-lg overflow-hidden border border-gray-200">
                              <img
                                src={url}
                                alt={`Screenshot preview ${index + 1}`}
                                className="w-full h-40 object-cover"
                              />
                              <div className="absolute top-1 right-1 bg-black bg-opacity-60 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs">
                                {index + 1}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="flex justify-end gap-4">
              <Button 
                type="button" 
                variant="outline" 
                onClick={() => navigate("/developer")}
              >
                Cancel
              </Button>
              <Button 
                type="submit" 
                disabled={uploadMutation.isPending}
              >
                {uploadMutation.isPending ? "Uploading..." : "Upload App"}
              </Button>
            </div>
          </form>
        </Form>
      </div>
  );
}